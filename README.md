# OpenSource Guard

---
## Table of content

- Introduction
  - [What problem does this tool solve?](#what-problem-does-this-tool-solve)
  - [What does this tool protect you from?](#what-does-this-tool-protect-you-from)
  - [Manifesto](#manifesto)
- In detail
  - [How it works?](#how-it-works)
  - [Usage notes](#usage-notes)
  - [The benefits of this tool](#the-benefits-of-this-tool)
    - [Little intro on used algorithms](#little-intro-on-these-algorithms)
- Usage
  - [Usage flow](#usage-flow)


---

## What problem does this tool solve?

- We are living times that anything public means it's not yours anymore.
- Anyone can grab your code, laugh at the licence, then reuse, repurpose, republish as their own, feed it to
  AI crawlers.
- Most “open-source protection” advice is utopian: blocklists, licenses, code etiquette.
- In reality, as in life the majority doesn't respect the rules but respect the gun.

TLDR: **This tool gives you hand-on protection for your open-source projects from code stealers.**

---

## What does this tool protect you from?

- AI crawlers.
- Those who will violate the license anyway.
- Individuals who modify the code and re-license it as their own.
- Other unwanted steals.

---

## Manifesto
1. No, _"not everything open-source is free to use. And if you think otherwise, then keep your code private."_
2. This is indeed the mentality of a typical scammer: unintelligent, selfish, greedy and ignorant. The one this tool opposes.

---

## How it works?

**The core idea** is in encoding the important and critical files of your open source code.

- E.g. abstraction layers, parts with heavy business logic, settings, file with constants, etc.

---

## Usage notes

- Use different keys in different parts of the program.
- Do not store the keys anywhere in the project, even encoded.
- Yes you can additionally obfuscate your code as well.
  - This actually depends on your preferences.

---

## The benefits of this tool

- It provides 2 in 1 choice. You can choose any of **AES-256 GCM** and **ChaCha20-Poly1305**.
- Moreover, it doesn't enforce you to encode all files with one algorithm.
- Moreover, you can rencode already encoded files with another algorithm, as many times as you want.

---

## Little intro on these algorithms

- **AES-256 GCM**: Industry standard, very secure, fast, and has built-in authentication (detects tampering). Perfect
  for encrypting source files.
- **ChaCha20-Poly1305**: Very fast, especially on mobile or low-power devices, and secure. A good alternative to AES if
  you want portability and performance.

---

## Usage flow

1. Encrypt the important files.
2. Save the autogenerated medatata json file somewhere handy, or directly the encryption keys to the deployment environment as variables (if available).
3. Upload the project to GitHub.


- Alternatively, you can have an automatic job to decrypt the project files (on startup).

---

## Usage example

```python
import os
from cryptography.hazmat.primitives.ciphers.aead import AESGCM  # cryptography is a sub-dependency package
from open_source_guard import OpenSourceGuard
from open_source_guard import MetadataDumper, MetadataLoader

# obtain the root, metadata json file's name, and the folder path to output it  
ROOT = os.path.dirname(__file__)
METADATA_JSON = "metadata.json"
METADATA_FOLDER = "metadata_folder"

# Prepare a container (list, tuple, set, etc) with file paths you want to encrypt 
files = 'tests/mock_files/file.py', 'tests/mock_files/file.txt'
files = [os.path.join(ROOT, file) for file in files]

# base object
ocg = OpenSourceGuard()

# encryption
# 
# 1. Create a dumper object, which needs:
#       - the root of your project
#       - metadata folder path
#       - metadata file name
#
# 2. Run .encrypt method of OpenSourceGuard, which needs:
#       - the root of your project
#       - metadata folder path
#       - metadata file name
#
# - It's gonna encrypt the files, and save the json metadata to metadata file in metadata folder
dumper = MetadataDumper(root=ROOT, metadata_folder=METADATA_FOLDER, metadata_filename=METADATA_JSON)
encryption_result = ocg.encrypt(files=files, metadata_dumper=dumper, algorithm=AESGCM)
print(encryption_result) # 3. Optionally print the result object


# decryption
#
# 1. Create a loader object, which needs:
#       - the root of your project
#       - metadata folder path
#       - metadata file name
#
# 2. Run .decrypt method of OpenSourceGuard, which needs:
#       - the root of your project
#       - metadata folder path
#       - metadata file name
#
# - It's gonna dencrypt the encrypted files using the json metadata file as blueprint 
loader = MetadataLoader(root=ROOT, metadata_folder=METADATA_FOLDER, metadata_filename=METADATA_JSON)
decryption_result = ocg.decrypt(metadata_loader=loader)
print(decryption_result)
```
